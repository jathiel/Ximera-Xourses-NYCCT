\documentclass{ximera}  
\title{Monte Carlo Simulations}  
\begin{document}  
\begin{abstract}  
We give an introduction to Monte Carlo simulations using NumPy.
\end{abstract}  
\maketitle

\section{Monte Carlo Simulations}

Suppose you flip a fair coin 500 times. What is the length of the longest streak of consecutive heads that you expect to see? Computing this value exactly requires some knowledge of probability theory and a decent amount of work. 

As an alternative to computing the theoretically expected value, you might consider running your own experiment: flipping a coin 500 times and counting the length of the longest streak of consecutive heads. This experiment could take a while to complete just once and it should be reasonable to think that you are going to have to repeat this experiment many times to get a sense of what happens on average.

The alternative described above seems to solve the problem of having to have specialized knowledge, but doing the experiment by hand seems time consuming. Why not use the computer to simulate the result of this experiment thousands of times? This type of approach is sometimes called a Monte Carlo simulation.

Monte Carlo simulations can be useful when:
	\begin{itemize}
		\item computing the probability of an event is difficult or
		\item running a physical experiment is too costly or time consuming.
	\end{itemize}
Our general approach to using Monte Carlo simulations will involve three key steps:
	\begin{enumerate}
		\item Identify the situation or experiment to be modelled.
		\item Simulate the result of one experiment using a computer program.
		\item Repeat the previous step many times.
	\end{enumerate}
Usually step (b) is the most challenging part. Once we can simulate the experiment once, we can wrap all of the code inside a function and then loop it.

\section{Random Sampling}

In order to run a Monte Carlo simulation, we are going to have to generate random numbers somehow. The NumPy library can help us with this. (For a list of available functions related to random sampling, see this \link[link]{https://numpy.org/doc/stable/search.html?q=Random\%20sampling\%20(numpy.random)}.) We will cover some basic examples here.
\begin{enumerate}
	\item \verb|np.random.rand()| - This generates a random number using the uniform distribution in the interval $[0,1)$.
	\item \verb|np.random.ranint(a,b,size=N)| - This generates a random integer in the interval $[a,b)$. The optional argument \verb|size| specifies how many samples we want.
	\item \verb|np.random.choice(myList, p = prob_list)| - This generates a random selection from \verb|myList|. The optional argument \verb|p| allows you to specify the probability of selecting each item on the list.
\end{enumerate}

\section{Examples}

\subsection{500 Coin Flip Streak}

We now simulate the length of the longest streak of consecutive heads (on average) in 500 fair coin flips. As a first step, we need to simulate the result of flipping 500 fair coins. We are going to use the \verb|np.random.randint| function on the interval $[0,1)$, where we will treat a 0 as tails and a 1 as heads.

\begin{sageCell}
import numpy as np

np.random.randint(0,1,size=500)
\end{sageCell}

The difficulty here is to write an algorithm that loops through the list of results and computes all the streaks of consecutive heads. We will do this by using a loop that will keep track of the current streak of consecutive heads. This will be done in the following way:
\begin{enumerate}
	\item Begin with an empty list, \verb|streak_list|, that will contain all of the streaks of consecutive heads.
	\item Initialize a counter, \verb|streak|, that begins at zero.
	\item Loop through the list of coin flips and apply the following rules at each step:
		\begin{itemize}
			\item if the current coin flip is heads, increase \verb|streak| by one,
			\item otherwise, append the current value of \verb|streak| to \verb|streak_list| and reset \verb|streak| to zero. (This signifies that the streak has ended.
		\end{itemize}
	\item Up \verb|np.max| to obtain the largest value of \verb|streak_list| to get the longest streak of consecutive heads.
\end{enumerate}

\begin{sageCell}
import numpy as np

coin_flips = np.random.randint(0,1,size=500)

streak_list = []
streak = 0

for coin in coin_flips:
        if coin == 1:
                streak += 1
        else:
                streak_list.append(streak)
                streak = 0

np.max(streak_list)end
\{sageCell}

The work above represents the result of one experiment. To approximate the expected length we have to repeat this experiment thousands of times and average the results. This can be done using by wrapping the code above in a function and using a list comprehension to compute the average result with the \verb|np.mean| function.

\begin{sageCell}
import numpy as np

def longest_streak()
        coin_flips = np.random.randint(0,1,size=500)

        streak_list = []
        streak = 0

        for coin in coin_flips:
                if coin == 1:
                        streak += 1
                else:
                        streak_list.append(streak)
                        streak = 0

        return np.max(streak_list)

np.mean(np.array([longest_streak() for i in range(100000]))
\end{sageCell}

\subsection{}

\subsection{Race to the Finish}

\section{Problems}

\begin{question}
\end{question}

\begin{question}
\end{question}

\begin{question}
\end{question}

\section{Workspace}

\begin{sageCell}
# Use this cell to solve the above questions.
\end{sageCell}

\end{document}
